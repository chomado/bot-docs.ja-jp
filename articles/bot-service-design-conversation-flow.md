---
title: 会話フローの設計と制御 | Microsoft Docs
description: ボットでの会話フローを設計および制御して、優れたユーザー エクスペリエンスを提供するす方法について説明します。
keywords: 設計, 制御, 会話フロー, 割り込みの処理, 概要
author: v-ducvo
ms.author: v-ducvo
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 12/19/2018
ms.openlocfilehash: 79c37a48f9312d60b61124e15780fe46236aa0c7
ms.sourcegitcommit: f7a8f05fc05ff4a7212a437d540485bf68831604
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/21/2018
ms.locfileid: "53735982"
---
::: moniker range="azure-bot-service-3.0"

# <a name="design-and-control-conversation-flow"></a>会話フローの設計と制御

[!INCLUDE [pre-release-label](./includes/pre-release-label-v3.md)]

従来のアプリケーションの場合、ユーザー インターフェイス (UI) とは一連の画面のことです。 
1 つのアプリや Web サイト上で、必要に応じて 1 つ以上の画面を使用し、ユーザーと情報を交換できます。 
多くのアプリケーションでは、起動するとまずメイン画面が表示され、ユーザーはそこに表示されたナビゲーションから別の画面に移動して、新しい注文を開始したり、製品を参照したり、ヘルプを検索したりします。

アプリや Web サイトと同様、ボットにも UI がありますが、ボットの UI は画面ではなく**ダイアログ**で構成されます。 ダイアログは、会話内でご自身の場所を保持したり、必要に応じてユーザーに入力を求めたり、入力の検証を実行したりするときに役立ちます。 これらは、複数ターンの会話やシンプルな "フォーム ベース" の情報コレクションを管理して、航空券の予約などのアクティビティを実行するうえで有効です。

ボットの開発者は、ダイアログを使用してボットの様々な機能領域を論理的に分離し、会話フローをガイドすることができます。 たとえば、あるダイアログには、ユーザーが製品を参照できるようにするためのロジックを実装し、別のダイアログには、ユーザーが新しい注文を作成できるようにするためのロジックを実装するといったことが可能です。 

ダイアログにグラフィカル インターフェイスを使用するかどうかは任意です。 ボタン、テキスト、およびその他の要素を含めることもできますし、完全に音声ベースにすることもできます。 また、ダイアログには、他のダイアログを呼び出したり、ユーザー入力を処理するなど、タスクを実行するためのアクションを含めることもできます。

## <a name="using-dialogs-to-manage-conversation-flow"></a>ダイアログを使用した会話フローの管理

[!INCLUDE [Dialog flow example](./includes/snippet-dotnet-manage-conversation-flow-intro.md)]

ダイアログと Bot Builder SDK を使用して会話フローを管理するための詳しいチュートリアルについては、次の記事をご覧ください。

- [ダイアログで会話フローを管理する (.NET)](./dotnet/bot-builder-dotnet-manage-conversation-flow.md)
- [ダイアログで会話フローを管理する (Node.js)](./nodejs/bot-builder-nodejs-manage-conversation-flow.md)

## <a name="dialog-stack"></a>ダイアログ スタック

あるダイアログが別のダイアログを呼び出すと、Bot Builder はダイアログ スタックの最上段に新しいダイアログを追加します。 
スタックの最上段にあるダイアログが、会話の制御権を保持します。 
ユーザーによって送信されたすべての新しいメッセージは、ダイアログが閉じるか別のダイアログにリダイレクトするまで、そのダイアログによる処理の対象になります。 
ダイアログが閉じると、そのダイアログはスタックから削除され、スタック内の直前のダイアログに会話の制御権が移ります。 

> [!IMPORTANT]
> ダイアログが別のダイアログを呼び出したり、ダイアログが閉じたりするときに、Bot Builder によってダイアログ スタックの構築や解体がどのように行われるのかを理解することは、ボットの会話フローを効果的に設計するうえできわめて重要です。 

## <a name="dialogs-stacks-and-humans"></a>ダイアログ、スタックおよび人間

フローの設計を検討する際には、ユーザーがダイアログ間を移動していくことでダイアログ スタックが作成され、その後ある時点で、ユーザーが移動してきた経路を戻っていくことで、ダイアログ スタックが 1 つずつ整然と解体されていくことを想定しがちです。 
これはたとえば、ユーザーがルート ダイアログから操作を開始し、そこから新規注文ダイアログを呼び出した後、製品検索ダイアログを呼び出すといった流れです。 
その後ユーザーは、製品を選択して確認し、製品検索ダイアログを終了し、注文を完了し、新規注文ダイアログを終了して、ルート ダイアログに戻ります。 

ユーザーが常にこのようなストレートな論理パスをたどってくれれば、それに越したことはないのですが、実際にはこのようなことはあまりありません。 
人間は "スタック" に基づいてやりとりをするわけではないからです。 ユーザーが心変わりすることは頻繁に起こりえます。 
次の例を考えてみます。 

![ボット](./media/bot-service-design-conversation-flow/stack-issue.png)

ダイアログのスタックがボットによって論理的に構築されていても、ユーザーは現在の操作とまったく違うことををしようとしたり、現在のトピックとは関係のない質問をしてくる場合があります。 
上記の例で言うと、はい/いいえの応答を返すはずの流れにおいて、ユーザーが逆に質問をしてきています。 
このような場合、ダイアログはどのように応答すべきでしょうか?

- まず質問に答えるよう、ユーザーに求める。 
- ユーザーがこれまでに行ったことをすべて無視し、ダイアログ スタック全体をリセットした後、ユーザーの質問に答えることで最初からやり直す。 
- ユーザーの質問に答えた後、はい/いいえの質問に戻り、そこから再開する。 

この質問に 1 つの "*正解*" はありません。なぜなら、どのようなシナリオが想定されるか、またはユーザーがボットにどのような応答を期待するかによって、最良の対応方法は変わってくるからです。 しかし、会話が複雑になると、**ダイアログ**の管理は困難になります。 分岐が複雑な場合は、ユーザーの会話を追跡するための独自の制御ロジックを作成する方が簡単なことがあります。

## <a name="next-steps"></a>次の手順

ダイアログ間でのユーザーの移動を管理し、ユーザーが (シナリオとは違った方法であっても) 目標を達成できるように会話フローを設計することは、ボット設計の基本的な課題です。 
[次の記事](./bot-service-design-navigation.md)では、ナビゲーション設計に関する一般的な落とし穴と、そのような失敗を回避するための戦略について説明します。 

::: moniker-end

::: moniker range="azure-bot-service-4.0"

# <a name="design-and-control-conversation-flow"></a>会話フローの設計と制御

従来のアプリケーションでは、ユーザー インターフェイス (UI) は一連の画面で構成されます。つまり、1 つのアプリや Web サイト上で、必要に応じて 1 つ以上の画面を使用し、ユーザーと情報を交換できます。
多くのアプリケーションでは、起動するとまずメイン画面が表示され、ユーザーはそこに表示されたナビゲーションから別の画面に移動して、新しい注文を開始したり、製品を参照したり、ヘルプを検索したりします。

アプリや Web サイトと同様、ボットにも UI がありますが、ボットの UI は画面ではなく**メッセージ**で構成されます。 メッセージでは、ボタン、テキスト、およびその他の要素を使用することもできますし、完全に音声ベースのメッセージにすることもできます。

従来のアプリケーションや Web サイトでは、複数の情報を 1 つの画面でまとめて要求することができますが、ボットでは、同じ量の情報を複数のメッセージによって収集します。 これにより、ユーザーからの情報収集プロセスをアクティブなエクスペリエンスにし、ユーザーがボットとアクティブに会話する流れを構築します。

ボットを適切に設計すれば、自然な会話フローを提供することができます。 ボットでは、中心となる会話をシームレスに処理しながらも、会話の中断やトピックの切り替わりにも柔軟に対応できるようにする必要があります。

## <a name="procedural-conversation-flow"></a>手続き型の会話フロー

通常、ボットによる会話は、そのボットが達成しようとしているタスクに焦点が置いて設計されます。これを手続き型フローと呼びます。 手続き型フローでは、ボットがユーザーに一連の質問をして、タスクを処理する前に必要なすべての情報を収集します。

手続き型の会話フローでは、質問の順序を定義することにより、ボットがそのとおりの順序で質問を発するようにします。 開発者は、質問を複数の論理*モジュール*にまとめてコードを一元化しながら、会話の流れを制御できるようにします。 たとえば、あるモジュールには、ユーザーが製品を参照できるようにするためのロジックを実装し、別のモジュールには、ユーザーが新しい注文を作成できるようにするためのロジックを実装するといったことが可能です。

これらのモジュールは、自由形式のフローからシーケンシャルなフローに至るまで、任意の方法で構築できます。 Bot Builder SDK では、ボットに必要な会話フローを自由に構築するできるよう、複数のライブラリが提供されています。 たとえば、`prompts` ライブラリを使用すればユーザーに入力を求めることができますし、`waterfall` ライブラリを使用すれば、一連の質問/回答ペアを定義することができます。また、`dialog control` ライブラリを使用すれば、会話フローのロジックをモジュール化することができます。これらのライブラリはすべて、`dialogs` オブジェクトを通じて相互に関連付けられています。 それでは、モジュールを `dialogs` として実装し、会話フローを設計および管理する方法についてもう少し詳しく見ていきながら、そのフローを従来のアプリケーション フローと比較してみましょう。

![ボット](./media/designing-bots/core/dialogs-screens.png)

従来のアプリケーションでは、すべての操作が**メイン画面**から開始されます。
この例では、まず**メイン画面**が**新規注文画面**を呼び出します。
**新規注文画面**は、画面が閉じられるか、他の画面 (**製品検索画面**など) が呼び出されるまで、制御権を保持します。
**新規注文画面**が閉じられると、ユーザーは**メイン画面**に戻されます。

これに対しボットでは、すべての操作が**ルート ダイアログ**から開始されます。
この例では、まず**ルート ダイアログ**が**新規注文ダイアログ**を呼び出します。
この時点で、**新規注文ダイアログ**に会話の制御権が渡され、ダイアログが閉じられるか、他のダイアログ (**製品検索ダイアログ**など) が呼び出されるまで、制御権を保持します。
**新規注文ダイアログ**が閉じられると、会話の制御権が**ルート ダイアログ**に戻されます。

会話フローの実装方法の例については、[ユーザー入力を収集するために独自のプロンプトを作成する](./v4sdk/bot-builder-primitive-prompts.md)方法と、ダイアログを使用した[連続して行われる会話フローの実装](./v4sdk/bot-builder-dialog-manage-conversation-flow.md)方法を参照してください。

## <a name="handle-interruptions"></a>割り込みの処理

ダイアログを開発する際には、ユーザーが手続き型タスクを 1 つずつ順序よく実行していくことを想定しがちです。
これはたとえば、`dialogs` を使った手続き型会話フローにおいて、ユーザーがルート ダイアログから操作を開始し、そこから新規注文ダイアログを呼び出した後、製品検索ダイアログを呼び出すといった流れです。 その後ユーザーは、製品を選択して確認し、製品検索ダイアログを終了し、注文を完了し、新規注文ダイアログを終了して、ルート ダイアログに戻ります。

ユーザーが常にこのようなストレートな論理パスをたどってくれれば、それに越したことはないのですが、実際にはこのようなことはあまりありません。
人間は手続き型の `dialogs` を通じてやりとりを行うわけではないからです。 ユーザーが心変わりすることは頻繁に起こりえます。
次の例を考えてみます。

![ボット](./media/bot-service-design-conversation-flow/stack-issue.png)

ボットが手続き型で設計されていても、ユーザーは現在の操作とまったく違うことをしようとしたり、現在のトピックとは関係のない質問をしてくる場合があります。
上記の例で言うと、はい/いいえの応答を返すはずの流れにおいて、ユーザーが逆に質問をしてきています。
このような場合、ボットはどのように応答すべきでしょうか?

- まず質問に答えるよう、ユーザーに求める。
- ユーザーがこれまでに行ったことをすべて無視し、ダイアログ スタック全体をリセットした後、ユーザーの質問に答えることで最初からやり直す。
- ユーザーの質問に答えた後、はい/いいえの質問に戻り、そこから再開する。

この質問に対する*正解*はありません。なぜなら、どのようなシナリオが想定されるかや、ユーザーがボットにどのような応答を期待するかによって、最良の対応方法は変わってくるからです。 詳しくは、「[ユーザーによる割り込みの処理](v4sdk/bot-builder-howto-handle-user-interrupt.md)」をご覧ください。

## <a name="next-steps"></a>次の手順

ダイアログ間でのユーザーの移動を管理し、ユーザーが (シナリオとは違った方法であっても) 目標を達成できるように会話フローを設計することは、ボット設計の基本的な課題です。
[次の記事](~/bot-service-design-navigation.md)では、ナビゲーション設計に関する一般的な落とし穴と、そのような失敗を回避するための戦略について説明します。

::: moniker-end
