---
title: テストとデバッグのガイドライン | Microsoft Docs
description: ご利用のボットをテストおよびデバッグする方法について説明します。
keywords: テストの原則, モック要素, FAQ, テスト レベル
author: ivorb
ms.author: v-ivorb
manager: kamrani
ms.topic: article
ms.prod: bot-framework
ms.date: 04/09/2018
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 4195ae016513c809e4677879e0abe1b2bf8d799e
ms.sourcegitcommit: 3cb288cf2f09eaede317e1bc8d6255becf1aec61
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/27/2018
ms.locfileid: "47389781"
---
# <a name="testing-and-debugging-guidelines"></a>テストとデバッグのガイドライン

[!INCLUDE [pre-release-label](../includes/pre-release-label.md)]

ボットは様々なパーツが連携する複雑なアプリです。 他の複雑なアプリと同様、これにより興味深いバグがいくつか発生したり、お使いのボットが期待どおりに動作しなかったりします。

お使いのボットのテストと、それ以降のデバッグは、場合によっては難しい作業になる可能性があります。 開発者それぞれが独自のやり方でそのタスクを実行しています。以下のガイドラインでは、大部分のボットに適用できる推奨事項を紹介します。

## <a name="testing-your-bot"></a>ご利用のボットのテスト

以下のガイドラインは、3 つの異なる**レベル**に分かれています。  レベルが進むごとにテストが複雑になり、機能も増えます。したがって、1 つのレベルについて十分に理解してから次のレベルに進むことをお勧めします。 そうすることで、複雑さが増す前に、まず下位レベルの問題を切り離して修正することができます。

ベスト プラクティスのテストでは、さまざまな角度から適宜説明を進めます。 これには、セキュリティ、統合、形式が正しくない URL、検証のエクスプロイト、HTTP 状態コード、JSON ペイロード、null 値などが含まれることがあります。 ユーザーのプライバシーに影響する情報が、ご利用のボットで処理されている場合、これは特に重要です。

### <a name="level-1-use-mock-elements"></a>レベル 1: モック要素の使用

最初のレベルのテストでは、アプリ (ここでは、ご利用のボット) を構成する小さな各部分が、期待どおり正確に動作していることを確認します。 これ行うために、現在のテスト対象以外の部分に対して、モック要素を使用できます。 なお、このレベルは、一般的に単体テストおよび統合テストとして考えることができます。

**モック要素を使用して、個々のセクションをテストする**

できるだけ多くの要素のモックを作成すると、テスト対象の各部分をより効果的に分離できます。 モック要素の候補としては、ストレージ、アダプター、ミドルウェア、アクティビティ パイプライン、チャネルなど、お使いのボットに直接含まれないものが挙げられます。 これにより、テスト対象のボットのパーツには関与しないミドルウェアなど、特定の側面を一時的に削除して、各部分を分離できます。 ただし、ミドルウェアをテストする場合は、代わりにお使いのボットのモックを作成することもできます。

要素のモック作成では、要素を別の既知のオブジェクトで置き換えたり、最小限の Hello World 機能を実装したりといった、複数の形をとることができます。 その要素が不要な場合は単純に削除したり、単にその要素が何も行わないよう強制したりすることもできます。 

このレベルでは、お使いのボット内で個別のメソッドと関数を実行する必要があります。 個別のメソッドのテストには、組み込みの単体テストを使用することをお勧めしますが、独自のテスト アプリまたはテスト スイートを使用するか、お使いの IDE 内で手動で実行することもできます。 

**モック要素を使用して、より大きな機能をテストする**

各メソッドの動作に問題が無ければ、これらのモック要素を使用して、お使いのボット内のより完全な機能をテストします。 ここでは、ユーザーとのやり取りを実現するために、複数のレイヤーがどのように連携しているかを示します。 

これを支援するためのツールがいくつかあります。 たとえば、[Azure Bot Framework エミュレータ―](https://github.com/Microsoft/BotFramework-Emulator)には、ご自身のボットと通信できるようにエミュレートされたチャネルが用意されています。 エミュレーターを使用すると、単体テストや統合テストよりも複雑な状況に対応できるようになるため、次のテスト レベルにまで関係してきます。

### <a name="level-2-use-a-direct-line-client"></a>レベル 2: ダイレクト ライン クライアントの使用

お使いのボットが意図したとおりに動作するように見えるのを確認したら、次はそのボットをチャネルに接続します。 これを行うには、ご自身のボットをステージング サーバーに展開し、そのボットの接続先となる <!--IBTODO [Direct Line client](bot-builder-howto-direct-line.md)--> ダイレクト ライン クライアントを作成します。

独自のクライアントを作成すると、チャネルの内部動作を定義できるほか、ご自身のボットが特定のアクティビティの交換に対してどのように応答するかを具体的にテストできます。 そのクライアントに接続されたら、テストを実行してボットの状態を設定し、お使いの機能を確認します。 お使いのボットで音声などの機能が使用されている場合は、これらのチャネルを使用して、その機能を確認する手段を提供できます。

ここで Azure portal からエミュレーターと Web チャットの両方を使用すると、さまざまなチャネルと対話しているときの、ご利用のボットの動作に関するより詳細な分析情報が得られます。

### <a name="level-3-channel-tests"></a>レベル 3: チャネルのテスト

お使いのボットの独立したパフォーマンスについて自信を持つことができたら、ボット利用の基盤となるさまざまなチャネルとどのように連携するかを確認することが重要です。 

これを実現する方法は非常に多様です。さまざまなチャネルやブラウザーを個別に使用することもできますし、[Selenium](https://docs.seleniumhq.org/) などのサード パーティ製ツールを使用して、チャネルを介して対話したり、ご自身のボットから応答を取得したりすることもできます。

### <a name="other-testing"></a>その他のテスト

上記のレベルと組み合わせて、あるいはさまざまな角度から、ストレス テスト、パフォーマンス テスト、お使いのボットのアクティビティのプロファイリングなど、各種テストを実行できます。 Visual Studio には、これをローカルで実行するためのメソッドや、ご自身のアプリをテストするための[一連のツール](https://azure.microsoft.com/en-us/solutions/dev-test/)が用意されています。また、[Azure portal](https://portal.azure.com) を使用すると、ご自身のボットの動作に関する分析情報が提供されます。

## <a name="debugging"></a>デバッグ

お使いのボットのデバッグは、他のマルチスレッド アプリと同様に動作し、ブレークポイントを設定する機能が用意されています。また、イミディエイト ウィンドウなどの機能を使用することもできます。 

ボットはイベント ドリブン方式のプログラミング パラダイムに従っています。このパラダイムに詳しくない場合、これを合理的に説明するのは困難です。 お使いのボットがステートレスかつマルチ スレッドであり、非同期/待機の呼び出しを処理するという考え方は、予期しないバグにつながることあります。 こうしたボットのデバッグは他のマルチスレッド アプリと同様に動作しますが、ここでは役に立つ提案、ツール、およびリソースをいくつか紹介します。

**エミュレーターを使用したボット アクティビティの理解**

お使いのボットでは、通常の "_メッセージ_" アクティビティだけでなく、さまざまな種類の[アクティビティ](bot-builder-basics.md#the-activity-processing-stack)が処理されます。 [エミュレーター](../bot-service-debug-emulator.md)を使用すると、それがどのようなアクティビティで、いつ発生し、どのような情報が含まれるかを確認できます。 これらのアクティビティを理解すると、ボットのコードを効率的に書いたり、ボットが送受信しているアクティビティが期待どおりのものかを確認したりするうえで役立ちます。

**ユーザーとの対話のトランスクリプトを保存して取得する**

Azure BLOB のトランスクリプト ストレージは、ユーザーとボットの間の対話が含まれる[トランスクリプトを格納して保存](bot-builder-howto-v4-storage.md)できる、特殊化されたリソースを提供します。  

さらに、ユーザー入力の対話が格納された後は、Azure の "_ストレージ エクスプローラー"_ を使用して、BLOB のトランスクリプト ストア内に格納されたトランスクリプトに含まれるデータを手動で確認できます。 次の例では、"_mynewtestblobstorage_" の設定から "_ストレージ エクスプローラー_" を開きます。 保存されたユーザー入力を開くには、[BLOB コンテナー] > [ChannelId] > [TranscriptId] > [ConversationId] の順に選択します。

![Examine_stored_transcript_text](./media/examine_transcript_text_in_azure.png)

これにより、JSON 形式で格納された会話のユーザー入力が開きます。 ユーザー入力はキーとなる "_text_" と共に保持されます。

**ミドルウェアのしくみ**

特に実行の継続やショートサーキットに関して言えば、初めて使う[ミドルウェア](bot-builder-concept-middleware.md)は直感的とは言えないでしょう。 ミドルウェアは、ボット ロジックに実行が渡されるタイミングをディクテーションする `next()` デリゲートへの呼び出しを使用して、ターンの立ち上がりまたは立ち下がりで実行できます。 

複数のミドルウェアを使用している場合は、お使いのパイプラインの方向付けに従って、デリゲートによって別のミドルウェアに実行が渡されることがあります。 詳細については、[ボットのミドルウェア パイプライン](bot-builder-concept-middleware.md#the-bot-middleware-pipeline)に関する記事をご覧ください。この考え方を、さらに明確に理解するうえで役立ちます。

`next()` デリゲートが呼び出されない場合、それは[ショート サーキット ルーティング](bot-builder-concept-middleware.md#short-circuiting)と呼ばれます。 ミドルウェアが現在のアクティビティを満たしている場合、そして実行を渡す必要ないと判断した場合に、これが発生します。 

ミドルウェアでショートサーキットが発生するタイミングと理由を理解すると、どのミドルウェアをパイプラインの先頭にするかを指定するときに役立ちます。 また、予期される結果を理解することは、SDK または他の開発者によって提供される組み込みのミドルウェアには特に重要です。 組み込みのミドルウェアを使用する前に、まず独自のミドルウェアを作成して少し実験してみると役立つ場合もあります。

たとえば [QnA Maker](bot-builder-howto-qna.md) は、特定のやり取りを処理し、それを実行するときにパイプラインをショートサーキットするように設計されていますが、その使用方法は最初はわかりにくい可能性があります。

**状態の理解**

特に複雑なタスクの場合、状態を追跡することが、お使いのボットにとっては重要です。 一般的に、ベスト プラクティスは、アクティビティをできるだけ迅速に処理し、状態が永続化されるようにその処理を完了させることです。 複数のアクティビティがほぼ同時にご使用のボットに送信されるため、非同期アーキテクチャが原因で、非常に紛らわしいバグが発生することがあります。

重要なのは、自分が意図したとおりに状態が永続化されているかどうかを確認することです。 永続化の状態が存在する場所によっては、[Cosmos DB](https://docs.microsoft.com/en-us/azure/cosmos-db/local-emulator) および [Azure Table Storage](https://docs.microsoft.com/en-us/azure/storage/common/storage-use-emulator) 用のストレージ エミュレーターが、運用環境のストレージを使用する前にその状態を確認するうえで役立つ場合があります。

**アクティビティ ハンドラーを使用する方法**

アクティビティ ハンドラーにより、別の複雑さが生じることがあります。具体的には、各アクティビティが独立したスレッドで実行されます (お使いの言語によっては Web worker で実行されます)。 ご利用のハンドラーが行っている処理によっては、現在の状態が、期待どおりのものではないという問題が発生することがあります。

組み込みの状態はターンの最後に書き込まれますが、そのターンによって生成されたアクティビティはすべて、ターン パイプラインとは無関係に実行されています。 多くの場合、この影響を受けることはありませんが、アクティビティ ハンドラーによって状態が変更された場合は、書き込まれたその状態に、その変更を含める必要があります。 この場合、ターン パイプラインは、アクティビティ上で処理が完了するのを待つことができます。これにより、完了前に、そのターンについて適切な状態が確実に記録されます。

単に _send activity_ メソッド内からそのメソッドを呼び出すと、スレッドの無限フォークが発生するため、ユーザーに何かを出力する場合、_send activity_ メソッドとそのハンドラーにより独自の問題が発生します。 この問題を回避する方法はいくつかあります。たとえば、デバッグ メッセージを送信情報に追加できます。また、コンソールやファイルのような別の場所に書き出して、お使いのボットのクラッシュを避けることもできます。


## <a name="additional-resources"></a>その他のリソース
* [Visual Studio でのデバッグ](https://docs.microsoft.com/en-us/visualstudio/debugger/index)
* Bot Framework のための[デバッグ、トレース、およびプロファイリング](https://docs.microsoft.com/en-us/dotnet/framework/debug-trace-profile/)
* 運用環境のコードに含めたくないメソッドに [ConditionalAttribute](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.conditionalattribute?view=netcore-2.0) を使用する 
* [Fiddler](https://www.telerik.com/fiddler) などのツールを使用してネットワーク トラフィックを確認する 
* [ボット ツール リポジトリ](https://github.com/Microsoft/botbuilder-tools)
* テストに役立つ [Moq](https://github.com/moq/moq4) などのフレームワーク
