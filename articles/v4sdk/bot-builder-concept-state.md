---
title: 状態の管理 | Microsoft Docs
description: Bot Framework SDK 内で状態がどのように機能するかについて説明します。
keywords: 状態, ボットの状態, 会話の状態, ユーザーの状態
author: ivorb
ms.author: v-ivorb
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 02/25/2019
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 024791aaf6aea0b09b097b275d4ca954fcd27ddf
ms.sourcegitcommit: 721bb09f10524b0cb3961d7131966f57501734b8
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/18/2019
ms.locfileid: "59508239"
---
# <a name="managing-state"></a>状態の管理

ボット内の状態は、最新の Web アプリケーションと同じパラダイムに従います。また、Bot Framework SDK には、状態の管理を容易にするための抽象化概念がいくつか用意されています。

Web アプリと同様、ボットは本質的にはステートレスです。つまり、お使いのボットの別のインスタンスで、会話の任意のターンを処理できます。 一部のボットには、このシンプルさが適しています。つまり、こうしたボットは追加情報なしで動作できるか、必要な情報が受信メッセージ内にあることが保証されています。 その他のボットについては、ボットで有用な会話を行うには、状態 (会話の進行状況や、それまでに受信しているユーザーに関するデータ) が必要になってきます。

**状態が必要な理由**

状態を維持すると、お使いのボットは、ユーザーまたは会話に関する特定の情報を記憶することで、より有意義な会話ができるようになります。 たとえば、前にユーザーと話したことがある場合は、ユーザーに関する以前の情報を保存できるため、その内容については再度尋ねる必要がありません。 また、状態によって現在のターンよりも長くデータが保持されるため、お使いのボットには、一連のマルチターンの会話にわたって情報が保持されます。

状態はボットと深く関連しているので、ここではその使用について、ストレージ レイヤー、状態管理 (以下の図に示すボットの状態に含まれる)、状態プロパティ アクセサーという観点から説明します。 この図は、これらのレイヤー間で行われる相互作用シーケンスの一部を示しています。実線の矢印はメソッドの呼び出しを、破線の矢印は応答 (戻り値の有無に関係なく) を表しています。

![ボットの状態](media/bot-builder-state.png)

この図のフローについては、次のセクションでレイヤーごとに詳しく説明します。

## <a name="storage-layer"></a>ストレージ レイヤー

バックエンドから開始します。状態情報が実際に格納されるのが "*ストレージ レイヤー*" です。 これは物理ストレージ (インメモリ、Azure、サード パーティのサーバーなど) と考えることができます。

Bot Framework SDK には、ストレージ レイヤー用の実装がいくつか用意されています。

- **メモリ ストレージ**により、テストを目的としたインメモリ ストレージが実装されます。 インメモリ データ ストレージは揮発性であり、一時的なものであるため、ローカル テストのみを対象としています。 ボットの再起動ごとにデータがクリアされます。
- **Azure Blob Storage** は、Azure Blob Storage オブジェクト データベースに接続されます。
- **Azure Cosmos DB ストレージ**は、Cosmos DB NoSQL データベースに接続されます。

他のストレージ オプションに接続する方法については、[ストレージへの直接書き込み](bot-builder-howto-v4-storage.md)に関するページをご覧ください。

## <a name="state-management"></a>状態管理

"*状態管理*" により、基盤となるストレージ レイヤーに対するボットの状態の読み取りと書き込みが自動化されます。 状態は、効率的なキーと値のペアである "*状態プロパティ*" として格納され、お使いのボットは、このプロパティを、基盤となる特定の実装を気にすることなく、状態管理オブジェクトを使用して読み書きできます。 これらの状態プロパティにより、その情報の格納方法が定義されます。 たとえば、特定のクラスまたはオブジェクトとして定義したプロパティを取得する場合、そのデータがどのように構造化されるかがわかります。

これらの状態プロパティはスコープ付きの "バケット" にまとめられます。これは、プロパティを整理しやすくするための単なるコレクションです。 SDK には、次の 3 つの "バケット" が含まれています。

- ユーザー状態
- 会話状態
- 個人的な会話状態

これらのバケットはすべて "*ボット状態*" クラスのサブクラスであり、これを基に他の種類のバケットをさまざまなスコープで定義できます。

これらの定義済みバケットは、バケットに応じて、使用できる範囲が限定されます。

- ユーザー状態は、会話に関係なく、ボットがそのチャンネルのそのユーザーと会話している任意のターンで使用できます
- 会話状態は、ユーザー (グループの会話) に関係なく、特定の会話の任意のターンで使用できます
- 個人的な会話状態は、特定の会話とその特定のユーザーの両方に対象が限定されます

> [!TIP]
> ユーザー状態と会話状態の両方がチャンネルごとに範囲指定されます。
> さまざまなチャンネルを使用してボットにアクセスしている 1 人のユーザーは、チャンネルごとにそのユーザーが存在し、ユーザー状態も異なるため、違うユーザーのように見えます。

これらの定義済みバケットそれぞれに使用されるキーは、ユーザー、会話、またはその両方に固有です。 お使いの状態プロパティの値を設定するとき、キーは、各ユーザーまたは会話がそれぞれ正しいバケットとプロパティに確実に配置されるように、ターン コンテキストに含まれる情報によって内部的に自動で定義されます。 具体的には、キーは次のように定義されます。

- ユーザー状態は、*channel ID* と *from ID* を使用してキーを生成します。 例: _{Activity.ChannelId}/users/{Activity.From.Id}#YourPropertyName_
- 会話状態は、*channel ID* と *conversation ID* を使用してキーを生成します。 例: _{Activity.ChannelId}/conversations/{Activity.Conversation.Id}#YourPropertyName_
- 個人的な会話状態は、*channel ID*、*from ID*、および *conversation ID* を使用してキーを生成します。 例: _{Activity.ChannelId}/conversations/{Activity.Conversation.Id}/users/{Activity.From.Id}#YourPropertyName_

### <a name="when-to-use-each-type-of-state"></a>それぞれの状態の種類を使用するタイミング

会話状態は、次のような会話のコンテキストの追跡に適しています。

- ボットがユーザーに質問したかどうかと、どのような質問を行ったか
- 会話の現在のトピック、または最後のトピック

ユーザー状態は、次のようなユーザーに関する情報の追跡に適しています。

- 重要度が低いユーザー情報。名前と基本設定、アラーム設定、アラートの基本設定など
- ユーザーがボットと交わした最後の会話に関する情報
  - たとえば、product-support ボットでは、ユーザーがどの製品について質問したかが追跡されている場合があります。

個人的な会話状態は、グループの会話をサポートするチャンネルに適しています。ただし、その会話ではユーザーおよび会話固有の情報を追跡する必要があります。 たとえば、クラスルーム クリッカー ボットは、次を実行できます。

- 特定の質問に対する学生の応答を集計し、表示する。
- 各学生のパフォーマンスを集計し、集計した内容を、セッションの最後に非公開で学生に送り返す。

これらの定義済みバケットの使用の詳細については、[状態に関するハウツー記事](bot-builder-howto-v4-state.md)をご覧ください。

### <a name="connecting-to-multiple-databases"></a>複数のデータベースへの接続

お使いのボットが複数のデータベースに接続する必要がある場合は、データベースごとにストレージ レイヤーを作成します。
ストレージ レイヤーごとに、ご自身の状態プロパティをサポートするのに必要な状態管理オブジェクトを作成します。

## <a name="state-property-accessors"></a>状態プロパティ アクセサー

"*状態プロパティ アクセサー*" は、状態プロパティのいずれかを実際に読み書きするときに使用され、ターン内からご自身の状態プロパティにアクセスするための *get*、*set*、*delete* の各メソッドを提供します。 アクセサーを作成するには、プロパティ名を指定する必要があります。この操作は、通常、ご自身のボットを初期化しているときに行います。 その後、そのアクセサーを使用して、ボットの状態の該当するプロパティを取得して操作できます。

アクセサーは、基盤となるストレージから SDK が状態を取得できるようにして、ボットの "*状態キャッシュ*" を自動的に更新します。 状態キャッシュは、ご自身のボットによって維持されているローカル キャッシュで、状態オブジェクトが自動的に格納されます。これにより、基盤となるストレージにアクセスしなくても読み書き操作を行えるようになります。 状態がキャッシュにない場合は、アクセサーの *get* メソッドを呼び出すことで状態が取得され、キャッシュへの配置も行われます。 状態が取得されると、ローカル変数と同じように、状態プロパティを操作できるようになります。

アクセサーの *delete* メソッドでは、プロパティが、キャッシュだけでなく、基盤となるストレージからも削除されます。

> [!IMPORTANT]
> アクセサーの *get* メソッドを初めて呼び出すとき、オブジェクトがまだ存在しない場合は、ファクトリ メソッドを指定して作成する必要があります。 ファクトリ メソッドを指定しないと、例外が発生します。 ファクトリ メソッドの使用方法の詳細については、[状態に関するハウツー記事](bot-builder-howto-v4-state.md)をご覧ください。

アクセサーから取得した状態プロパティに対する変更を保持するには、状態キャッシュのプロパティを更新する必要があります。 これを行うには、アクセサーの *set* メソッドを呼び出します。これにより、キャッシュでご自身のプロパティ値が設定され、後からそのターンで読み取りまたは更新の必要が出てきた場合に使用できます。 そのデータを基盤となるストレージに実際に保持するには (つまり、現在のターンの後に使用できるようにするには)、[その状態を保存](#saving-state)する必要があります。

### <a name="how-the-state-property-accessor-methods-work"></a>状態プロパティのアクセサー メソッドのしくみ

アクセサー メソッドは、ご自身のボットで状態を操作する最も一般的な方法です。 それぞれのしくみと、基盤となるレイヤーの動作を次に示します。

- アクセサーの *get* メソッド:
  - アクセサーが状態キャッシュにプロパティを要求します。
  - プロパティがキャッシュにある場合は、それを返します。 それ以外の場合は、状態管理オブジェクトから取得します。
    (まだ状態にない場合は、アクセサーの *get* 呼び出しで指定されたファクトリ メソッドを使用します。)
- アクセサーの *set* メソッド:
  - 新しいプロパティ値で状態キャッシュを更新します。
- 状態管理オブジェクトの *save changes* メソッド:
  - 状態キャッシュのプロパティへの変更を確認します。
  - そのプロパティをストレージに書き込みます。

## <a name="saving-state"></a>状態の保存

アクセサーの set メソッドを呼び出して、更新された状態を記録するとき、その状態プロパティは、永続化されたストレージにはまだ保存されておらず、ご自身のボットの状態キャッシュに保存されているだけです。 状態キャッシュの変更をご自身の永続化された状態に保存するには、状態管理オブジェクトの *save changes* メソッドを呼び出す必要があります。このメソッドは、前述したボット状態クラス (ユーザー状態、会話状態など) の実装で使用できます。

状態管理オブジェクト (つまり、上述したバケット) の save changes メソッドを呼び出すと、そのバケットについては、その時点までに設定した状態キャッシュにすべてのプロパティが保存されますが、ご自身のボットの状態に存在する可能性がある他のバケットについては、プロパティは保存されません。

> [!TIP]
> ボットの状態では、"最後の書き込みが有効" という動作が実装されます。つまり、以前に書き込まれた状態は、最後の書き込みで上書きされます。 これは多くのアプリケーションで有効ですが、特に、ある程度のコンカレンシーまたは待ち時間が存在する可能性があるスケールアウト シナリオに、影響が及ぶことがあります。

ターン ハンドラーの完了後に状態を更新する可能性のある何らかのカスタム ミドルウェアがある場合は、[ミドルウェアで状態を処理](bot-builder-concept-middleware.md#handling-state-in-middleware)することを検討してください。

## <a name="additional-resources"></a>その他のリソース

- [ダイアログの状態](bot-builder-concept-dialog.md#dialog-state)
- [ストレージに直接書き込む](bot-builder-howto-v4-storage.md)
- [会話とユーザーのデータを保存する](bot-builder-howto-v4-state.md)
