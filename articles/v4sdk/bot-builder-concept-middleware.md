---
title: ミドルウェア | Microsoft Docs
description: ミドルウェアと、ボット SDK 内でのその用途について理解します。
keywords: ミドルウェア, ミドルウェア パイプライン, 短絡, ミドルウェアの用途
author: ivorb
ms.author: v-ivorb
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 11/8/2018
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 1bfa180967c55aac6012e02887ac2893947263f9
ms.sourcegitcommit: 91156d0866316eda8d68454a0c4cd74be5060144
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/07/2018
ms.locfileid: "53010587"
---
# <a name="middleware"></a>ミドルウェア

[!INCLUDE [pre-release-label](../includes/pre-release-label.md)]

ミドルウェアとは単に、アダプターとボット ロジックの間に位置し、初期化中にアダプターのミドルウェア コレクションに追加されるクラスのことです。 SDK を使用すると、独自のミドルウェアを記述したり、他のユーザーによって作成されたミドルウェアを追加したりできます。 ボットを出入りするすべてのアクティビティはミドルウェアを通って流れます。

アダプターは、ボットのミドルウェア パイプラインを通ってボットのロジックに入ってきた後、また出ていくアクティビティを処理および管理します。 各アクティビティがボットを出入りして流れる際、ボット ロジックの実行前と実行後のどちらでも、各ミドルウェアがアクティビティを検査または操作できます。

ミドルウェアを使用してみる前に、[ボット全般](~/v4sdk/bot-builder-basics.md)および[ボットによるアクティビティの処理方法](~/v4sdk/bot-builder-basics.md#the-activity-processing-stack)を理解することが重要です。

## <a name="uses-for-middleware"></a>ミドルウェアの用途
よくある疑問は、「どのような場合にミドルウェアとしてアクションを実装し、どのような場合に通常のボット ロジックを使用するのか」ということです。 ミドルウェアは、処理される会話の各_ターン_の前後の両方に、ユーザーの会話フローとやり取りをする追加の機会を提供します。 また、ミドルウェアを使用して、会話に関する情報を取得して格納し、必要に応じて追加の処理ロジックを呼び出すことができます。 以下にミドルウェアが役に立つ場面を示す一般的なシナリオを示します。

### <a name="looking-at-or-acting-on-every-activity"></a>すべてのアクティビティに注目する、またはそれらに基づいて行動する
すべてのアクティビティ、または特定の種類のすべてのアクティビティに対してボットが何かをしなければならない状況は多々あります。 たとえば、ボットが受け取ったすべてのメッセージ アクティビティをログに記録する、あるいは、ボットがこのターンに別の方法で応答を生成しなかった場合にフォールバック応答を提供することが必要な場合があります。 ミドルウェアはこのための優れた場所ですが、その理由は、ボット ロジックの残りの部分の実行前と実行後のどちらでも動作できることです。

### <a name="modifying-or-enhancing-the-turn-context"></a>ターン コンテキストの変更または強化
アクティビティで提供されるものよりも多くの情報をボットが持っている場合、特定の会話の有用性が大きく向上します。 この場合のミドルウェアは、それまでに持っていた会話状態情報に注目し、外部データ ソースをクエリし、実行をボット ロジックに渡す前にそれを[ターン コンテキスト](~/v4sdk/bot-builder-basics.md#defining-a-turn) オブジェクトに追加することができます。 

SDK は受信および送信アクティビティを記録できるログ記録ミドルウェアを定義しますが、独自のミドルウェアを定義することもできます。

## <a name="the-bot-middleware-pipeline"></a>ボットのミドルウェア パイプライン
アダプターはアクティビティごとに、追加された順にミドルウェアを呼び出します。 アダプターはターンのコンテキスト オブジェクトと _next_ デリゲートを渡し、ミドルウェアはデリゲートを呼び出してパイプライン内の次のミドルウェアに制御を渡します。 ミドルウェアには、_next_ デリゲートが戻った後、メソッドを完了する前に処理を行う機会もあります。 パイプラインの次のミドルウェア オブジェクトとの関係上、各ミドルウェア オブジェクトには最初で最後の行動チャンスがあると考えることができます。

例: 

- 1 番目のミドルウェア オブジェクトのターン ハンドラーは、_next_ を呼び出す前にコードを実行します。
  - 2 番目のミドルウェア オブジェクトのターン ハンドラーは、_next_ を呼び出す前にコードを実行します。
    - ボットのターン ハンドラーが実行され、戻ります。
  - 2 番目のミドルウェア オブジェクトのターン ハンドラーは、戻る前に残りのコードをすべて実行します。
- 1 番目のミドルウェア オブジェクトのターン ハンドラーは、戻る前に残りのコードをすべて実行します。

ミドルウェアが next デリゲートを呼び出さない場合、アダプターは後続のミドルウェアまたはボットのターン ハンドラーのどれも呼び出さず、パイプラインは短絡されます。

ボットのミドルウェア パイプラインが完了すると、ターンは終了し、ターン コンテキストはスコープ外になります。

ミドルウェアまたはボットは、応答を生成して応答イベント ハンドラーを登録できますが、応答は別々のプロセスで処理されることに注意してください。

## <a name="order-of-middleware"></a>ミドルウェアの順序
ミドルウェアが追加された順序によってミドルウェアがアクティビティを処理する順序が決まるため、ミドルウェアを追加する順序の決定は重要です。

> [!NOTE]
> これは、ほとんどのボットに役立つ共通のパターンを与えることを意図していますが、特定の状況で各ミドルウェアがどのように相互作用するかを必ず検討してください。

ミドルウェア パイプラインの最初のミドルウェアは、多くの場合、毎回使われる最も低レベルのタスクを処理するものになります。 たとえば、ログ記録、例外処理、翻訳などです。 これらの順序はニーズによって変わることがあります。たとえば、受信メッセージが格納される前に翻訳するか、それともメッセージを先に格納するか (この場合、格納されたメッセージは翻訳されない) によって変わります。

ミドルウェア パイプラインの最後のミドルウェアはボット固有のミドルウェアにしてください。これは、ボットに送信されるすべてのメッセージに対して何らかの処理を行うために実装するミドルウェアです。 ボットのコンテキストに設定されている状態情報またはその他の情報をミドルウェアで使用する場合、そのミドルウェアをミドルウェア パイプラインに追加するときは、状態またはコンテキストを変更するミドルウェアよりも後に追加します。

## <a name="short-circuiting"></a>短絡
ミドルウェアおよび応答ハンドラーに関する重要なアイデアは "_短絡_" です。 実行がその後のレイヤーにわたって継続する場合、ミドルウェア (または応答ハンドラー) はその _next_ デリゲートを呼び出すことによって実行を渡す必要があります。  next デリゲートがそのミドルウェア (または応答ハンドラー) 内で呼び出されない場合、関連付けられているパイプラインは短絡され、後続のレイヤーは実行されません。 つまり、すべてのボット ロジックと、パイプラインでそれよりもさらに先のすべてのミドルウェアはスキップされます。 ミドルウェアと応答ハンドラーによるターンの短絡の間には、微妙な違いがあります。

ミドルウェアによるターンの短絡では、ボットのターン ハンドラーは呼び出されませんが、パイプライン内でこの時点より前に実行されたミドルウェアのすべてのコードは引き続き完了するまで実行されます。 

イベント ハンドラーの場合、_next_ を呼び出さないことはイベントがキャンセルされることを意味します。これは、ミドルウェアのスキップ ロジックとは大きく異なる結果です。 イベントの残りの部分を処理しないことにより、アダプターは決してそのイベントを送信しません。

> [!TIP]
> `SendActivities` のような応答イベントを短絡する場合は、それが意図した動作であることを確認してください。 それ以外の場合、バグの修正が困難になることがあります。

## <a name="response-event-handlers"></a>応答イベント ハンドラー
アプリケーションおよびミドルウェア ロジックに加えて、応答ハンドラー (イベント ハンドラーやアクティビティ イベント ハンドラーと呼ばれることもある) をコンテキスト オブジェクトに追加することもできます。 これらのハンドラーは、実際の応答が実行される前に、現在のコンテキスト オブジェクト上で関連する応答が発生したときに呼び出されます。 これらのハンドラーは、実際のイベントの前または後で、現在の応答の残りの部分でその種類のすべてのアクティビティのために何かを行う必要があることがわかっているときに便利です。

> [!WARNING]
> アクティビティ応答メソッドを、そのそれぞれの応答イベント ハンドラー内から呼び出さないように注意してください。たとえば、send activity メソッドを on send activity ハンドラー内から呼び出さないようにしてください。 それを行うと、無限ループが生成される可能性があります。

それぞれの新しいアクティビティには、新しいスレッドが与えられ、それぞれ対応するスレッドで実行されることに留意してください。 アクティビティを処理するスレッドが作成されると、そのアクティビティ用のハンドラー リストが、その新しいスレッドにコピーされます。 そのポイントより後に追加されたハンドラーは、その特定のアクティビティ イベントに対して実行されません。
コンテキスト オブジェクトに登録されたハンドラーは、アダプターがミドルウェア パイプラインを管理する場合とよく似た方法で処理されます。 具体的には、ハンドラーはそれらが追加された順に呼び出され、next デリゲートを呼び出すと、次に登録されているイベント ハンドラーに制御が渡されます。 次のデリゲートがハンドラーによって呼び出されない場合、後続のイベント ハンドラーは呼び出されません。イベントは短絡状態となり、アダプターからチャネルに応答は送信されません。

## <a name="handling-state-in-middleware"></a>ミドルウェアでの状態の処理

状態を保存する一般的な方法は、ターン ハンドラーの最後に、変更の保存メソッドを呼び出すというものです。 この呼び出しに焦点を当てた図を次に示します。

![状態ミドルウェアの問題](media/bot-builder-dialog-state-problem.png)

このアプローチの問題は、ボットのターン ハンドラーが戻った後に発生する、カスタム ミドルウェアで行われた状態の更新が永続ストレージに保存されないことです。 これを解決するには、変更の保存メソッドへの呼び出しを、カスタム ミドルウェアの完了後に移動するか ("_変更の自動保存_" ミドルウェアのインスタンスをミドルウェア スタックの最初に追加)、少なくとも、状態を更新する可能性があるミドルウェアの前に移動します。 実行は次のようになります。

![状態ミドルウェアの解決策](media/bot-builder-dialog-state-solution.png)

更新する必要がある状態管理オブジェクトを "_ボット状態セット_" オブジェクトに追加し、変更の自動保存ミドルウェアを作成するときに使用します。

## <a name="additional-resources"></a>その他のリソース
Bot Builder SDK [[C#](https://github.com/Microsoft/botbuilder-dotnet/blob/master/libraries/Microsoft.Bot.Builder/TranscriptLoggerMiddleware.cs) | [JS](https://github.com/Microsoft/botbuilder-js/blob/master/libraries/botbuilder-core/src/transcriptLogger.ts)] に実装されているトランスクリプト ロガー ミドルウェアもご覧ください。
