---
title: ミドルウェア | Microsoft Docs
description: ミドルウェアと、ボット SDK 内でのその用途について理解します。
keywords: ミドルウェア, ミドルウェア パイプライン, 短絡, ミドルウェアの用途
author: ivorb
ms.author: v-ivorb
manager: kamrani
ms.topic: article
ms.prod: bot-framework
ms.date: 05/24/2018
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: d8201da0fb406f30888dfaa4ff6017f125990104
ms.sourcegitcommit: 2dc75701b169d822c9499e393439161bc87639d2
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/24/2018
ms.locfileid: "42905376"
---
# <a name="middleware"></a>ミドルウェア

[!INCLUDE [pre-release-label](../includes/pre-release-label.md)]

ミドルウェアとは単に、アダプターとボット ロジックの間に位置し、初期化中にアダプターのミドルウェア コレクションに追加されるクラスのことです。 SDK を使用すると、独自のミドルウェアを記述したり、他のユーザーによって作成されたミドルウェアの再利用可能なコンポーネントを追加したりできます。 ミドルウェアでは何ができるのでしょうか?  ほとんど何でもできます...ボットを出入りするすべてのアクティビティはミドルウェアを通って流れます。

アダプターは、ボットのミドルウェア パイプラインを通ってボットのロジックに入ってきた後、また出ていくアクティビティを処理および管理します。 各アクティビティがボットを出入りして流れる際、ボット ロジックの実行前と実行後のどちらでも、各ミドルウェアがアクティビティを検査または操作できます。

ミドルウェアを使用してみる前に、[ボット全般](~/v4sdk/bot-builder-basics.md)および[ボットによるアクティビティの処理方法](~/v4sdk/bot-builder-concept-activity-processing.md)を理解することが重要です。

## <a name="uses-for-middleware"></a>ミドルウェアの用途

ミドルウェアとボット ロジックの違いは何か、というのはよくある質問です。 ミドルウェアはかなり柔軟であり、結局のところ使う人次第です。 ここでは、ミドルウェアの適切な用途を 2 つ紹介します。

### <a name="looking-at-or-acting-on-every-activity"></a>すべてのアクティビティに注目する、またはそれらに基づいて行動する

すべてのアクティビティ、または特定の種類のすべてのアクティビティに対してボットが何かをしなければならない状況は多々あります。 たとえば、ボットが受け取ったすべてのメッセージ アクティビティをログに記録する、あるいは、ボットがこのターンに別の方法で応答を生成しなかった場合にフォールバック応答を提供することが必要な場合があります。 ミドルウェアはこのための優れた場所ですが、その理由は、ボット ロジックの残りの部分の実行前と実行後のどちらでも動作できることです。

### <a name="modifying-or-enhancing-the-turn-context"></a>ターン コンテキストの変更または強化

アクティビティで提供されるものよりも多くの情報をボットが持っている場合、特定の会話の有用性が大きく向上します。 この場合のミドルウェアは、それまでに持っていた会話状態情報に注目し、外部データ ソースをクエリし、実行をボット ロジックに渡す前にそれを[ターン コンテキスト](bot-builder-concept-activity-processing.md#turn-context) オブジェクトに追加することができます。
たとえばミドルウェアは、会話の ID や状態などの会話の詳細を識別した後、ディレクトリ サービスに情報を問い合わせることができます。 ミドルウェアは、その外部クエリから受け取ったユーザー オブジェクトをコンテキスト オブジェクトに追加してそれを渡すことで、ユーザーに関してより多くのデータを提供し、ボットがより適切に要求を処理することを可能にします。

ミドルウェアは上記の両方の用途に分類されることもあれば、まったく別の用途に分類されることもあります。すべては、ボットをどのように構造化したいのか、またボットが何を達成しようとしているのかによって決まります。
ミドルウェアは、状態を確立または永続化する、受信要求に反応する、あるいはパイプラインを短絡することができます。
ミドルウェアの候補には次のものがあります。

- **ストレージまたは永続性**: ミドルウェアを使用して、ターン後に値を保存または永続化するか、そのターンで起きたことに基づいて一部の値を更新します。
- **エラー処理または穏便な失敗処理**: 例外がスローされた場合、ミドルウェアはその例外に関してユーザーに分かりやすいメッセージを送信できます。
- **翻訳**: このミドルウェアは、受信メッセージを検出して翻訳したり、検出された受信言語に送信メッセージが翻訳されるように設定したりできます。

独自のミドルウェアを定義できます。または、アプリケーションから独立した次のようなコンポーネントを表すいくつかのミドルウェアを SDK が定義します。

- コンテキスト オブジェクトの状態情報を永続化および復元する状態ミドルウェア。 SDK は会話とユーザー状態のミドルウェアを提供します。
- 入力言語を認識し、アプリケーションが理解できる言語などの別言語に翻訳できる翻訳ミドルウェア。
- 受信アクティビティと送信アクティビティを記録できるログ記録ミドルウェア。

## <a name="the-bot-middleware-pipeline"></a>ボットのミドルウェア パイプライン

アダプターはアクティビティごとに、**追加された順に**ミドルウェアを呼び出します。 アダプターはターンのコンテキスト オブジェクトと _next_ デリゲートを渡し、ミドルウェアはデリゲートを呼び出してパイプライン内の次のミドルウェアに制御を渡します。 ミドルウェアには、_next_ デリゲートが戻った後、メソッドを完了する前に処理を行う機会もあります。 パイプラインの次のミドルウェア オブジェクトとの関係上、各ミドルウェア オブジェクトには最初で最後の行動チャンスがあると考えることができます。

例: 

- 1 番目のミドルウェア オブジェクトのターン ハンドラーは、_next_ を呼び出す前にコードを実行します。
  - 2 番目のミドルウェア オブジェクトのターン ハンドラーは、_next_ を呼び出す前にコードを実行します。
    - ボットのターン ハンドラーが実行され、戻ります。
  - 2 番目のミドルウェア オブジェクトのターン ハンドラーは、戻る前に残りのコードをすべて実行します。
- 1 番目のミドルウェア オブジェクトのターン ハンドラーは、戻る前に残りのコードをすべて実行します。

ミドルウェアが next デリゲートを呼び出さない場合、アダプターは後続のミドルウェアまたはボットのターン ハンドラーのどれも呼び出さず、パイプラインは短絡されます。

ボットのミドルウェア パイプラインが完了すると、ターンは終了し、ターン コンテキストはスコープ外になります。

ミドルウェアまたはボットは、応答を生成して応答イベント ハンドラーを登録できますが、応答は別々のプロセスで処理されることに注意してください。

## <a name="order-of-middleware"></a>ミドルウェアの順序

ミドルウェアが追加された順序によってミドルウェアがアクティビティを処理する順序が決まるため、ミドルウェアを追加する順序の決定は重要です。

> [!NOTE]
> これは、ほとんどのボットに役立つ共通のパターンを与えることを意図していますが、特定の状況で各ミドルウェアがどのように相互作用するかを必ず検討してください。

ミドルウェア パイプラインの最初のミドルウェアは、多くの場合、毎回使われる最も低レベルのタスクを処理するものになります。 たとえば、ログ記録、例外処理、状態管理、翻訳などです。 これらの順序はニーズによって変わることがあります。たとえば、例外処理が可能になる前にまず受信メッセージを翻訳するか、それとも例外処理を先にするか (この場合、例外メッセージは翻訳されない) によって変わります。

ミドルウェア パイプラインの最後のミドルウェアはボット固有のミドルウェアにしてください。これは、ボットに送信されるすべてのメッセージに対して何らかの処理を行うために実装するミドルウェアです。 ボットのコンテキストに設定されている状態情報またはその他の情報をミドルウェアで使用する場合、そのミドルウェアをミドルウェア パイプラインに追加するときは、状態またはコンテキストを変更するミドルウェアよりも後に追加します。

## <a name="short-circuiting"></a>短絡

ミドルウェア (および[イベント ハンドラー](~/v4sdk/bot-builder-concept-activity-processing.md#response-event-handlers)) に関する重要なアイデアは_短絡_です。 実行がその後のレイヤーにわたって継続する場合、ミドルウェア (またはハンドラー) はその _next_ デリゲートを呼び出すことによって実行を渡す必要があります。  next デリゲートがそのミドルウェア (またはハンドラー) 内で呼び出されない場合、現在のパイプラインは短絡され、後続のレイヤーは実行されません。 つまり、すべてのボット ロジックと、パイプラインでそれよりも後のすべてのミドルウェアはスキップされます。

イベント ハンドラーの場合、_next_ を呼び出さないことはイベントがキャンセルされることを意味します。これは、ミドルウェアのスキップ ロジックとは大きく異なる結果です。 イベントの残りの部分を処理しないことにより、アダプターは決してそのイベントを送信しません。

> [!TIP]
> `SendActivities` のようなイベントを短絡する場合は、それが意図した動作であることを確認してください。 そうしないと、非常に混乱を招くバグが発生する可能性があります。

## <a name="next-steps"></a>次の手順

これでボットのいくつかの主な概念について説明しましたので、次にボットから事前対応型のメッセージを送信する方法を詳細まで掘り下げてみましょう。

> [!div class="nextstepaction"]
> [プロアクティブ メッセージング](~/v4sdk/bot-builder-proactive-messages.md)
