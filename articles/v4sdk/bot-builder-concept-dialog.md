---
title: Bot Builder SDK 内のダイアログ | Microsoft Docs
description: ダイアログとは何か、またダイアログは Bot Builder SDK 内でどのように機能するのかについて説明します。
keywords: 会話フロー, プロンプト, ダイアログの状態, 意図の認識, 1 ターン, 複数ターン, ボットの会話, ダイアログ, プロンプト, ウォーターフォール, ダイアログ セット
author: johnataylor
ms.author: johtaylo
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 11/22/2018
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 964d4a0344df595630f5b38fa32b3cc3a526ed5c
ms.sourcegitcommit: bbfb171f515c50a3c8bba5ca898daf25cf764378
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/23/2018
ms.locfileid: "52293594"
---
# <a name="dialogs-library"></a>ダイアログ ライブラリ

[!INCLUDE [pre-release-label](../includes/pre-release-label.md)]

会話を管理するうえで、SDK での中心的な概念となるのが、ダイアログという考え方です。 ダイアログ オブジェクトは、受信されたアクティビティを処理し、送信する応答を生成します。 ボットのビジネス ロジックは、ダイアログ クラス内から直接または間接的に実行されます。

実行時には、ダイアログ インスタンスがスタック内に配置されます。 スタックの最上部にあるダイアログは、ActiveDialog と呼ばれます。 受信されたアクティビティは、現在のアクティブ ダイアログによって処理されます。 スタックは、会話のターンが次に移るまでそのまま維持されます (これは期限付きではないため、数日間にわたる場合もあります)。 

## <a name="dialog-lifecycle"></a>ダイアログのライフサイクル

ダイアログでは、次の 3 つの主要機能が実装されます。
- BeginDialog
- ContinueDialog
- ResumeDialog

実行時には、Dialogs クラスと DialogContext クラスが連携して、アクティビティを処理するための適切なダイアログが選択されます。 DialogContext クラスは、維持されているダイアログ スタックと、受信されたアクティビティ、および DialogSet クラスを相互に関連付けます。 DialogSet には、ボットから呼び出せるダイアログが保持されます。

DialogContext のインターフェイスには、ダイアログの開始と続行という基本概念が反映されます。 アプリケーションの一般的なパターンとして、最初は必ず ContinueDialog が呼び出されます。 スタックが存在しない場合は、ActiveDialog もないので、アプリケーションは DialogContext に対して BeginDialog を呼び出し、選択したダイアログを開始します。 これにより、対応するダイアログ エントリが DialogSet からスタックへとプッシュされます(厳密には、ダイアログの ID がスタックに追加されます)。その後、特定のダイアログ オブジェクトに対する BeginDialog の呼び出しが委任されます。 ActiveDialog がある場合は、そのダイアログの ContinueDialog に対する呼び出しが委任され、維持中のプロパティがそのダイアログに関連付けられます。

なお、**ダイアログの BeginDialog** は初期化コードであり、初期化プロパティを保持します (コード内では、"option" と呼ばれます)。**ダイアログの ContinueDialog** は、スタックの維持中にアクティビティが受信された際、実行を継続するためのコードです。 たとえば、ユーザーに質問をするダイアログの場合、BeginDialog で質問をし、ContinueDialog で応答を待機します。

ダイアログの入れ子 (ダイアログに子ダイアログを持たせる機能) をサポートするために、別の継続方法も用意されています。再開という方法です。 この方法を使用した場合、DialogContext は子ダイアログが完了すると、親ダイアログに対して ResumeDialog メソッドを呼び出します。

SDK で提供されているダイアログの具体的な例としては、プロンプトとウォーターフォールがあります。 多くのシナリオは、これらの抽象化要素を構成することで構築されますが、実際に実行されるロジックは、常に同じ方法で開始されます (つまり、ここで説明している継続や再開のパターン)。 

Bot Builder SDK の **Dialog** ライブラリには、ボットの会話を管理するのに役立つ、"_プロンプト_"、"_ウォーターフォール ダイアログ_"、"_コンポーネント ダイアログ_" などの組み込み機能が用意されています。 プロンプトは、さまざまな種類の情報についてユーザーに質問をするために使用できます。ウォーターフォールを使用すると、複数のステップを特定の順序で組み合わせることができます。コンポーネント ダイアログでは、ダイアログ ロジックを個別のクラスにパッケージ化して、他のボットに統合することができます。
## <a name="waterfall-dialogs-and-prompts"></a>ウォーターフォール ダイアログとプロンプト

**Dialog** ライブラリには、さまざまな種類のユーザー入力を収集するために使用できる、各種のプロンプトが用意されています。 たとえば、ユーザーにテキストの入力を求めるための **TextPrompt**、数字の入力を求めるための **NumberPrompt**、日時の入力を求めるための **DateTimePrompt** などがあります。 プロンプトはダイアログの種類の 1 つです。 ウォーターフォール ダイアログからプロンプトを使用するには、ウォーターフォールとプロンプトの両方を同じダイアログ セットに追加します。 

プロンプトと応答のやり取りの性質上、プロンプトを実装するには、ウォーターフォール ダイアログに少なくとも 2 つのステップを含める必要があります。1 つはプロンプトを送信するためのステップで、もう 1 つは、応答をキャプチャして処理するためのステップです。  追加のプロンプトがある場合は、ユーザーの応答を処理した後に次のプロンプトを開始する単一の関数を使用することで、これらを結合することもできます。

`WaterfallDialog` は、ユーザーから情報を収集したり、一連のタスクをユーザーに案内したりするときに使用されるダイアログ実装です。 タスクは関数の配列として実装されます。最初の関数の結果が次の関数に引数として渡され、その後も同様に処理されていきます。 各関数は、通常は、プロセス全体の 1 つのステップを表します。 各ステップで、ボットはユーザーに入力を要求し、応答を待った後、結果を次のステップに渡します。 

プロンプトとウォーターフォールはどちらもダイアログです。クラス階層を次に示します。 

![ダイアログのクラス](media/bot-builder-dialog-classes.png)

ウォーターフォール ダイアログは、一連のウォーターフォールステップで構成されます。 各ステップが、_ウォーターフォール ステップ コンテキスト_ (`step`) パラメーターをとる非同期デリゲートとなっています。 ウォーターフォール ステップで最後に実行されることは、子ダイアログ (通常はプロンプト) を開始することか、ウォーターフォール自体を終了することです。 次の図は、ウォーターフォール ステップの順序と、実行されるスタック操作を示したものです。

![ダイアログの概念](media/bot-builder-dialog-concept.png)

ダイアログからの戻り値は、ダイアログのウォーターフォール ステップ内か、ボットのアクティブ ハンドラーから処理できます。
ウォーターフォール ステップ内では、ウォーターフォール ステップ コンテキストの _result_ プロパティに戻り値が返されます。
通常、ダイアログ ターン結果の状態は、ボットのターン ロジックからチェックするだけで十分です。

## <a name="about-prompt-types"></a>プロンプトの種類について

バックグラウンドでは、プロンプトは 2 つのステップから成るダイアログです。 プロンプトでは、最初のステップで入力を要求し、2 番目のステップで有効な値を返すか、最初からやり直して再度入力を要求します。 ダイアログ ライブラリには、多数の基本的なプロンプトが用意されており、それぞれ異なる種類の応答の収集に使用されます。 基本的なプロンプトでは、数を表す "ten" や "a dozen"、日時を表す "tomorrow" や "Friday at 10am" など、自然言語の入力を解釈できます。

| Prompt | 説明 | 戻り値 |
|:----|:----|:----|
| _添付ファイル プロンプト_ | ドキュメントや画像など、1 つ以上の添付ファイルを要求します。 | "_添付ファイル_" オブジェクトのコレクション。 |
| _選択プロンプト_ | 一連のオプションから選択するよう求めます。 | "_見つかった選択肢_" オブジェクト。 |
| _確認プロンプト_ | 確認を求めます。 | ブール値。 |
| _日時プロンプト_ | 日時の入力を求めます。 | "_日時解決_" オブジェクトのコレクション。 |
| _数値プロンプト_ | 数値の入力を求めます。 | 数値。 |
| _テキスト プロンプト_ | 一般的なテキスト入力を求めます。 | 文字列。 |

ユーザーに入力を求めるには、組み込みクラスのいずれかを使用してプロンプト (_"テキスト プロンプト"_ など) を定義し、ダイアログ セットに追加します。 プロンプトには固定 ID があります。この ID は、ダイアログ セット内で一意である必要があります。 プロンプトごとにカスタム検証コントロールを含めることができます。一部のプロンプトについては、"_既定のロケール_" を指定できます。 

### <a name="prompt-locale"></a>プロンプトのロケール

ロケールは、**選択**、**確認**、**日時**、**数値**の各プロンプトの言語固有の動作を決定するために使用されます。 ユーザーからの任意の入力に対して、チャネルがユーザーのメッセージで _locale_ プロパティを提供した場合は、このロケールが使用されます。 それ以外の場合、プロンプトのコンストラクターの呼び出し時に指定するか、後で設定することによって、プロンプトの "_既定のロケール_" が設定されていれば、それが使用されます。 どちらも指定されていない場合は、ロケールとして英語 ("en-us") が使用されます。 注: ロケールは、言語または言語ファミリを表す 2、3、または 4 文字の ISO 639 コードです。

## <a name="dialog-state"></a>ダイアログの状態

ダイアログはマルチターンの会話を実装するためのアプローチの 1 つであり、複数のターンにわたって保持された状態に依存する、SDK の機能の一例です。 ダイアログに状態がなければ、お使いのボットは、ダイアログ セットにおける自身の位置や、自身が既に収集した情報を認識できません。

ダイアログ ベースのボットには、通常、そのボット実装のメンバー変数としてダイアログ セット コレクションが保持されます。 そのダイアログ セットは、保持されている状態へのアクセスを提供する、アクセサーというオブジェクトへのハンドルを使用して作成されます。 ボット内の状態の背景情報については、[状態の管理](bot-builder-concept-state.md)に関するページをご覧ください。 

![ダイアログの状態](media/bot-builder-dialog-state.png)

ボットのターン ハンドラーが呼び出されると、ボットはダイアログ セットで *create context* を呼び出すことにより、ダイアログのサブシステムを初期化します。これにより、*dialog context* が返されます。 ダイアログ コンテキストを作成するには状態が必要です。これには、ダイアログ セットの作成時に指定されたアクセサーを使ってアクセスします。 そのアクセサーを使用すると、ダイアログ セットは、適切なダイアログ状態の JSON を取得できます。 そのダイアログ コンテキストには、ダイアログに必要な情報が含まれています。

状態アクセサーの詳細については、[会話およびユーザー データの保存](bot-builder-howto-v4-state.md)に関するページをご覧ください。

## <a name="repeating-a-dialog"></a>ダイアログの繰り返し

ダイアログを繰り返すには、*replace dialog* メソッドを使用します。 ダイアログ コンテキストの *replace dialog* メソッドは、現在のダイアログをスタックから取り除き、それに置き換わるダイアログをスタックの一番上にプッシュして、そのダイアログを開始します。 このメソッドを使用して、ダイアログをそれ自体に置き換えることでループを作成できます。 現在のダイアログ ボックスの内部状態を維持する必要がある場合は、_replace dialog_ メソッドへの呼び出しで、ダイアログの新しいインスタンスに情報を渡した後、ダイアログを適切に初期化する必要があります。 新しいダイアログに渡されたオプションには、ダイアログの任意のステップで、ステップ コンテキストの _options_ プロパティを通じてアクセスできます。 これは、複雑な会話フローを処理したり、メニューを管理したりするのに便利な方法です。

## <a name="branch-a-conversation"></a>会話の分岐

ダイアログ コンテキストでは "_ダイアログ スタック_" が保持され、スタックのダイアログごとに、次のステップが追跡されます。 _begin dialog_ メソッドは、ダイアログをスタックの一番上にプッシュし、_end dialog_ メソッドは一番上のダイアログをスタックから取り除きます。

ダイアログでは、ダイアログ コンテキストの _begin dialog_ メソッドを呼び出し、新しいダイアログの ID を指定することで、同じダイアログ セット内で新しいダイアログを開始できます。これにより、新しいダイアログがアクティブ ダイアログになります。 元のダイアログは引き続きスタック上に残りますが、ダイアログ コンテキストの _continue dialog_ メソッドへの呼び出しは、スタックの一番上のダイアログ ("_アクティブ ダイアログ_") にのみ送信されます。 ダイアログがスタックから取り除かれると、ダイアログ コンテキストは、スタックのウォーターフォールの次のステップに移り、元のダイアログが中断されたところから再開されます。

つまり、会話フロー内に分岐を作成するには、ダイアログにステップを追加して、利用可能な一連のダイアログの中から、開始するダイアログを条件に応じて選択できるようにします。

## <a name="component-dialog"></a>コンポーネント ダイアログ
場合によっては、さまざまなシナリオで使用できる、再利用可能なダイアログが必要になることもあります。 たとえば、郵便番号、市区町村、番地の入力を求めるダイアログなどです。 

ComponentDialog では、個別の DialogSet を使用してダイアログを分離させることができます。 個別 DialogSet を使用することで、格納元の親ダイアログとの名前の競合を回避しながら、(独自の DialogContext を作成して) 独立した内部ダイアログ ランタイムを作成し、そこにアクティビティをディスパッチすることができます。 このセカンダリ ディスパッチにより、アクティビティをインターセプトすることが可能になっています。 これは、"ヘルプ" や "キャンセル" などの機能を実装するのに非常に便利です。  [Enterprise Bot Template](https://aka.ms/abs/templates/cabot) のサンプルを参照してください。 

## <a name="next-steps"></a>次の手順

> [!div class="nextstepaction"]
> [ユーザー入力を収集するためにダイアログ ライブラリを使用する](bot-builder-prompts.md)
