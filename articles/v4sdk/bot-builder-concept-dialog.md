---
title: Bot Builder SDK 内のダイアログ | Microsoft Docs
description: ダイアログとは何か、またダイアログは Bot Builder SDK 内でどのように機能するのかについて説明します。
keywords: 会話フロー, 意図の認識, 1 ターン, 複数ターン, ボットの会話, ダイアログ, プロンプト, ウォーターフォール, ダイアログ セット
author: johnataylor
ms.author: johtaylo
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 9/22/2018
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 88022c387d5f9ef7f645be74010aba3c676efadc
ms.sourcegitcommit: cb0b70d7cf1081b08eaf1fddb69f7db3b95b1b09
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/09/2018
ms.locfileid: "51332936"
---
# <a name="dialogs-library"></a>ダイアログ ライブラリ

[!INCLUDE [pre-release-label](../includes/pre-release-label.md)]

会話を管理するうえで、SDK での中心的な概念となるのが、ダイアログという考え方です。 ダイアログ オブジェクトは、受信されたアクティビティを処理し、送信する応答を生成します。 ボットのビジネス ロジックは、ダイアログ クラス内から直接または間接的に実行されます。

実行時には、ダイアログ インスタンスがスタック内に配置されます。 スタックの最上部にあるダイアログは、ActiveDialog と呼ばれます。 受信されたアクティビティは、現在のアクティブ ダイアログによって処理されます。 スタックは、会話のターンが次に移るまでそのまま維持されます (これは期限付きではないため、数日間にわたる場合もあります)。 

## <a name="dialog-lifecycle"></a>ダイアログのライフサイクル

ダイアログでは、次の 3 つの主要機能が実装されます。
- BeginDialog
- ContinueDialog
- ResumeDialog

実行時には、Dialogs クラスと DialogContext クラスが連携して、アクティビティを処理するための適切なダイアログが選択されます。 DialogContext クラスは、維持されているダイアログ スタックと、受信されたアクティビティ、および DialogSet クラスを相互に関連付けます。 DialogSet には、ボットから呼び出せるダイアログが保持されます。

DialogContext のインターフェイスには、ダイアログの開始と続行という基本概念が反映されます。 アプリケーションの一般的なパターンとして、最初は必ず ContinueDialog が呼び出されます。 スタックが存在しない場合は、ActiveDialog もないので、アプリケーションは DialogContext に対して BeginDialog を呼び出し、選択したダイアログを開始します。 これにより、対応するダイアログ エントリが DialogSet からスタックへとプッシュされます(厳密には、ダイアログの ID がスタックに追加されます)。その後、特定のダイアログ オブジェクトに対する BeginDialog の呼び出しが委任されます。 ActiveDialog がある場合は、そのダイアログの ContinueDialog に対する呼び出しが委任され、維持中のプロパティがそのダイアログに関連付けられます。

なお、**ダイアログの BeginDialog** は初期化コードであり、初期化プロパティを保持します (コード内では、"option" と呼ばれます)。**ダイアログの ContinueDialog** は、スタックの維持中にアクティビティが受信された際、実行を継続するためのコードです。 たとえば、ユーザーに質問をするダイアログの場合、BeginDialog で質問をし、ContinueDialog で応答を待機します。

ダイアログの入れ子 (ダイアログに子ダイアログを持たせる機能) をサポートするために、別の継続方法も用意されています。再開という方法です。 この方法を使用した場合、DialogContext は子ダイアログが完了すると、親ダイアログに対して ResumeDialog メソッドを呼び出します。

SDK で提供されているダイアログの具体的な例としては、プロンプトとウォーターフォールがあります。 多くのシナリオは、これらの抽象化要素を構成することで構築されますが、実際に実行されるロジックは、常に同じ方法で開始されます (つまり、ここで説明している継続や再開のパターン)。 ダイアログ クラスを一から実装する方法は比較的高度なトピックになりますが、[サンプル](https://github.com/Microsoft/BotBuilder-samples)にはその例が示されています。

Bot Builder SDK の **Dialog** ライブラリには、ボットの会話を管理するのに役立つ、"_プロンプト_"、"_ウォーターフォール ダイアログ_"、"_コンポーネント ダイアログ_" などの組み込み機能が用意されています。 プロンプトは、さまざまな種類の情報についてユーザーに質問をするために使用できます。ウォーターフォールを使用すると、複数のステップを特定の順序で組み合わせることができます。コンポーネント ダイアログでは、ダイアログ ロジックを個別のクラスにパッケージ化して、他のボットに統合することができます。
## <a name="waterfall-dialogs-and-prompts"></a>ウォーターフォール ダイアログとプロンプト

**Dialog** ライブラリには、さまざまな種類のユーザー入力を収集するために使用できる、各種のプロンプトが用意されています。 たとえば、ユーザーにテキストの入力を求めるための **TextPrompt**、数字の入力を求めるための **NumberPrompt**、日時の入力を求めるための **DateTimePrompt** などがあります。 プロンプトはダイアログの種類の 1 つです。 ウォーターフォール ダイアログからプロンプトを使用するには、ウォーターフォールとプロンプトの両方を同じダイアログ セットに追加します。 

プロンプトと応答のやり取りの性質上、プロンプトを実装するには、ウォーターフォール ダイアログに少なくとも 2 つのステップを含める必要があります。1 つはプロンプトを送信するためのステップで、もう 1 つは、応答をキャプチャして処理するためのステップです。  追加のプロンプトがある場合は、ユーザーの応答を処理した後に次のプロンプトを開始する単一の関数を使用することで、これらを結合することもできます。

`WaterfallDialog` は、ユーザーから情報を収集したり、一連のタスクをユーザーに案内したりするときに使用されるダイアログ実装です。 タスクは関数の配列として実装されます。最初の関数の結果が次の関数に引数として渡され、その後も同様に処理されていきます。 各関数は、通常は、プロセス全体の 1 つのステップを表します。 各ステップで、ボットはユーザーに入力を要求し、応答を待った後、結果を次のステップに渡します。 

プロンプトとウォーターフォールはどちらもダイアログです。クラス階層を次に示します。 

![ダイアログのクラス](media/bot-builder-dialog-classes.png)

ウォーターフォール ダイアログは、一連のウォーターフォールステップで構成されます。 各ステップが、_ウォーターフォール ステップ コンテキスト_ (`step`) パラメーターをとる非同期デリゲートとなっています。 ウォーターフォール ステップで最後に実行されることは、子ダイアログ (通常はプロンプト) を開始することか、ウォーターフォール自体を終了することです。 次の図は、ウォーターフォール ステップの順序と、実行されるスタック操作を示したものです。

![ダイアログの概念](media/bot-builder-dialog-concept.png)

ダイアログからの戻り値は、ダイアログのウォーターフォール ステップ内か、ボットのアクティブ ハンドラーから処理できます。
ウォーターフォール ステップ内では、ウォーターフォール ステップ コンテキストの _result_ プロパティに戻り値が返されます。
通常、ダイアログ ターン結果の状態は、ボットのターン ロジックからチェックするだけで十分です。

## <a name="repeating-a-dialog"></a>ダイアログの繰り返し

ダイアログを繰り返すには、*replace dialog* メソッドを使用します。 ダイアログ コンテキストの *replace dialog* メソッドは、現在のダイアログをスタックから取り除き、それに置き換わるダイアログをスタックの一番上にプッシュして、そのダイアログを開始します。 このメソッドを使用して、ダイアログをそれ自体に置き換えることでループを作成できます。 現在のダイアログ ボックスの内部状態を維持する必要がある場合は、_replace dialog_ メソッドへの呼び出しで、ダイアログの新しいインスタンスに情報を渡した後、ダイアログを適切に初期化する必要があります。 新しいダイアログに渡されたオプションには、ダイアログの任意のステップで、ステップ コンテキストの _options_ プロパティを通じてアクセスできます。 これは、複雑な会話フローを処理したり、メニューを管理したりするのに便利な方法です。

## <a name="branch-a-conversation"></a>会話の分岐

ダイアログ コンテキストでは "_ダイアログ スタック_" が保持され、スタックのダイアログごとに、次のステップが追跡されます。 _begin dialog_ メソッドは、ダイアログをスタックの一番上にプッシュし、_end dialog_ メソッドは一番上のダイアログをスタックから取り除きます。

ダイアログでは、ダイアログ コンテキストの _begin dialog_ メソッドを呼び出し、新しいダイアログの ID を指定することで、同じダイアログ セット内で新しいダイアログを開始できます。これにより、新しいダイアログがアクティブ ダイアログになります。 元のダイアログは引き続きスタック上に残りますが、ダイアログ コンテキストの _continue dialog_ メソッドへの呼び出しは、スタックの一番上のダイアログ ("_アクティブ ダイアログ_") にのみ送信されます。 ダイアログがスタックから取り除かれると、ダイアログ コンテキストは、スタックのウォーターフォールの次のステップに移り、元のダイアログが中断されたところから再開されます。

つまり、会話フロー内に分岐を作成するには、ダイアログにステップを追加して、利用可能な一連のダイアログの中から、開始するダイアログを条件に応じて選択できるようにします。

## <a name="component-dialog"></a>コンポーネント ダイアログ
場合によっては、さまざまなシナリオで使用できる、再利用可能なダイアログが必要になることもあります。 たとえば、郵便番号、市区町村、番地の入力を求めるダイアログなどです。 

ComponentDialog では、個別の DialogSet を使用してダイアログを分離させることができます。 個別 DialogSet を使用することで、格納元の親ダイアログとの名前の競合を回避しながら、(独自の DialogContext を作成して) 独立した内部ダイアログ ランタイムを作成し、そこにアクティビティをディスパッチすることができます。 このセカンダリ ディスパッチにより、アクティビティをインターセプトすることが可能になっています。 これは、"ヘルプ" や "キャンセル" などの機能を実装するのに非常に便利です。  詳しくは、Enterprise Bot Template のサンプルをご覧ください。 

## <a name="next-steps"></a>次の手順

> [!div class="nextstepaction"]
> [ユーザー入力を収集するためにダイアログ ライブラリを使用する](bot-builder-prompts.md)
